Рефакторинг - внесення у код змін, які не змінюють функціональность
(поведінку) коду. Можна вважаьи поліморфізмом, так як зміни відбуваються
із постійною алгоритмічною суттю. Якщо зміни вносяться в алгоритм то це не є рефакторинг.
Мета: знайти найбільш оптимальну форму вираження коду.
	for(i:1..10) print(i)
	while(i<10) print(i++)
	do print(i++) while(i<10)
	print(i) { if(i==10) return ; else print(i+1) } - рекурсія
	range(10).forEach(print)

питання оптимальності є відкритми, тобто перед рефакторингом слід це питання
вирішити. У ХР це - простота (Simple Design) - зрозумілість (всередині команди).
(+ стандарти кодування, + метафора системи)


Основні прийоми рефакторингу
Можна виділити окремі прийоми, але
- не всі можливості рефакторингу будуть реалізовані (перебрані)
- багато прийомів мають протилежні значення ( перенесення поля до батька/до нащадка)
- прийоми парадигмо-орієнтовані (сильно залежать від парадигми, частіше - ООП)

Боротьба з антипатернами
 - "Магічне число" - поява у коді числа (окрім 0 та 1), сенс якого незрозумілий
	(або неочевидний) який сенс?
	int getRating() {
		return numberOfLateDeliveries > 5 ? 2 : 1;
	}
	ключові проблеми:
	 = одночасна зміна у кількох місцях (при зміні числа)
	 = можливий конфлікт з іншими числами тієї ж величини
 - "Магічний рядок" - те ж саме, яле з рядком, різновид "Hardcored string"
	 if( login == "admin") { - "Магічний рядок"
		print("Hello") - Hardcored string
	 }

Можливі рішення:
 - "Магічне число":
  = Enum
	+(для обмежених переліків: рейтинг)
	-(для неперервних даних: кількість протермінованих замовлень)
  = Константи
	+ іменування, розкриття сенсу (через ім'я)
	- зміни вимагають перекомпіляції
  = Кофігурація (в окремому файлі)
	+ можливість змін без перекомпіляції

Проблема: "роздутий" код (метод, клас, файл тощо)
Ознака(критерій): окремий блок коду можна поєднати своїм коментарем

class{
	method{							| region
		instruction					| for
		instruction		| algo		| smth
		instruction		| for		| 
		instruction		| smth		| 
		instruction		| 			| 
		instruction					| 
	}								| 
	method{							| 
		instruction					| 
		instruction					| 
		instruction					| 
	}								| 
	method{
		instruction
		instruction
		instruction
	}
}

Алтернативні критерії:
- блок коду (метод, клас, файл) не влазить на один "екран" (25-40 рядків)
- 7 +- 2

Критика: занадто розгалужений код, для розуміння цілісної картини
необхідно переглянути велику кількість файлів
--------------------------------------------------------

Проблема: Змішування алгоритмів (порушення Single Responsibility / Splicity)
Ознака: в одному блоці вирішується декілька задач (перевірка + дія)
foreach(var item in items){
	if(item.name == null) ...
	else { widget.add(item) }
}
Наслідки: ускладнення змін однієї з задач, "зачіпання" іншої задачі
Рішення: розділення задач
Критика: збільшення працеємності, оскільки повторюються цикли та подібні конструкції

items = items.filter( item => item.name != null )
widget.addAll( items )
